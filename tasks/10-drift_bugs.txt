### 1. DRY: Consolidate Mathematical Logic
The `cosineSimilarity` function is implemented identically in two places: `src/retrieval/math.js` (used by the Worker) and `src/embeddings.js` (used by the Main Thread).
*   **Problem:** If you decide to optimize the math (e.g., using TypedArrays), you have to update it in two places.
*   **Fix:** `src/embeddings.js` should import `cosineSimilarity` from `src/retrieval/math.js`.

### 2. SOLID: Standardize JSON Repair
`src/utils/text.js` provides a `safeParseJSON` wrapper, but `src/extraction/parser.js` imports the `repairJson` vendor library directly and implements its own try/catch.
*   **Problem:** Inconsistent error logging and configuration of the repair logic.
*   **Fix:** Use the `safeParseJSON` utility in `src/extraction/parser.js`.

### 3. DRY: Centralize Message Tracking logic
Utilities for determining which messages are extracted vs. unextracted are split between `src/utils.js` and `src/extraction/scheduler.js`.
*   **Problem:** `src/utils.js` contains `getExtractedMessageIds` and `getUnextractedMessageIds`, but `src/extraction/scheduler.js` *also* contains a more updated version of `getExtractedMessageIds` that accounts for `PROCESSED_MESSAGES_KEY`.
*   **Fix:** Delete the versions in `src/utils.js` and have the rest of the app import exclusively from `src/extraction/scheduler.js`.

### 4. Logic Bug: Token Estimation Inconsistency
You have an `estimateTokens` function in `src/utils/text.js` that uses a `3.5` divisor. However:
*   In `src/retrieval/formatting.js`, you manually calculate overhead using `/ 4`.
*   In `src/retrieval/scoring.js`, you estimate memory cost using the same utility.
*   **Problem:** Small deviations in estimation logic across the "Pipeline" can lead to context overflows or under-utilization of the budget.
*   **Fix:** Use the centralized `estimateTokens` for all overhead and memory calculations.

---

### Suggested Implementation Refactors

#### Refactor `src/embeddings.js` (DRY)
```javascript
// src/embeddings.js
import { cosineSimilarity } from './retrieval/math.js'; // Import existing logic
// Remove the local cosineSimilarity definition
```

#### Refactor `src/extraction/parser.js` (SOLID)
```javascript
// src/extraction/parser.js
import { safeParseJSON, generateId, log } from '../utils.js'; // Use utility

export function parseExtractionResult(jsonString, messages, characterName, userName, batchId = null) {
    const parsed = safeParseJSON(jsonString); // Standardized parsing
    if (!parsed) return [];
    
    const events = Array.isArray(parsed) ? parsed : [parsed];
    // ... rest of logic
}
```

#### Refactor `src/retrieval/retrieve.js` (DRY)
The logic for "Get hidden memories" is duplicated in `retrieveAndInjectContext` and `updateInjection`. 
*   **Fix:** Create a private helper `_getHiddenMemories(chat, memories)` to ensure the definition of "Context Memory" (memories whose source messages are now system-hidden) is consistent.

### What you should NOT refactor (YAGNI/KISS)
*   **State Management:** Do not implement a complex state library (Redux/Store). The `operationState` object in `state.js` is perfectly adequate for the simple locking requirements of an ST extension.
*   **Class-based UI:** The jQuery patterns used in `src/ui/browser.js` are the standard for SillyTavern. Refactoring to a Component-based system would be over-engineering.
*   **Worker Module Type:** While some browsers struggle with `type: 'module'` workers, SillyTavern's target environment (modern Chrome/Firefox) handles this well. Keep it for the clean imports of `math.js`.

**Verdict:** Fix the **Cosine Similarity duplication** and the **JSON Parser inconsistency** immediately, as these are the most likely to cause "drift" bugs as the project grows.