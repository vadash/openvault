### 1. The "Alphabetical Key" Bug (Data Integrity)
In `src/extraction/parser.js`, relationship keys are created using `${charA}<->${charB}` based on the LLM's output order. 
**The Issue:** If the LLM outputs `Alice -> Bob` one time and `Bob -> Alice` another, you will end up with two separate relationship entries (`Alice<->Bob` and `Bob<->Alice`) for the same two people.

**Refactor:**
```javascript
// src/extraction/parser.js - updateRelationshipsFromEvents
const match = relationKey.match(/^(.+?)\s*->\s*(.+)$/);
if (!match) continue;
const [, charA, charB] = match;

// REFACTOR: Always sort names to ensure a unique key regardless of direction
const sortedNames = [charA, charB].sort();
const key = `${sortedNames[0]}<->${sortedNames[1]}`;
```

### 2. Narrator Mode False Positives (Logic Bug)
In `src/pov.js`, `detectPresentCharactersFromMessages` uses `text.includes(charName)`.
**The Issue:** If you have a character named "Will" or "May", or "Al" (short for Alice), the logic will trigger a "character present" flag on common English words (e.g., "I will go").

**Refactor:**
```javascript
// src/pov.js - detectPresentCharactersFromMessages
// REFACTOR: Use Regex with word boundaries
for (const charName of knownCharacters) {
    const escapedName = charName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`\\b${escapedName}\\b`, 'i');
    if (regex.test(text)) {
        presentCharacters.add(charName);
    }
}
```

### 3. DRY Event Listener Management (Maintainability)
`src/events.js` manually adds and removes listeners. This is prone to "ghost listeners" if you add a new event but forget to update the cleanup logic.

**Refactor:**
```javascript
// src/events.js
const EVENT_MAP = [
    ['GENERATION_AFTER_COMMANDS', onBeforeGeneration],
    ['GENERATION_ENDED', onGenerationEnded],
    ['MESSAGE_RECEIVED', onMessageReceived],
    ['CHAT_CHANGED', onChatChanged]
];

export function updateEventListeners() {
    const { eventSource, event_types } = getDeps();
    
    // Cleanup and Register in one loop
    EVENT_MAP.forEach(([type, handler]) => {
        eventSource.removeListener(event_types[type], handler);
        if (isAutomaticMode()) {
            eventSource.on(event_types[type], handler);
        }
    });

    if (!isAutomaticMode()) safeSetExtensionPrompt('');
}
```

### 4. UI Bottleneck: Memory Browser (Performance)
`src/ui/browser.js` currently wipes the DOM and re-appends in a loop. For users with 500+ memories, this causes a "stutter" in the SillyTavern UI.

**Refactor:**
Use a **Document Fragment** to batch DOM updates.

```javascript
// src/ui/browser.js - renderMemoryBrowser
const $list = $('#openvault_memory_list');
const fragment = document.createDocumentFragment(); // REFACTOR

for (const memory of pageMemories) {
    // ... build $item via jQuery ...
    fragment.appendChild($item[0]); // Append the raw DOM node to fragment
}

$list.empty().append(fragment); // Single DOM reflow
```

### 5. Smart Retrieval Fallback (Robustness)
In `src/retrieval/scoring.js`, if the LLM fails to return JSON, it calls `selectRelevantMemoriesSimple`. 
**The Issue:** `selectRelevantMemoriesSimple` is `async` because it triggers the Web Worker. The current fallback inside `selectRelevantMemoriesSmart` is correctly `await`ed, but the logic inside the simple selection *re-calculates* embeddings.

**Optimization:** Pass the `contextEmbedding` down through the chain to prevent calling the Embedding API twice on a single retrieval failure.

---

### What should we NOT refactor?
*   **The Prompts:** While long, they follow Claude's XML standard. Keep the examples in the prompt; removing them to save tokens (YAGNI) will drastically reduce extraction quality.
*   **The Web Worker:** Even though it adds complexity, it is vital. ST is single-threaded; calculating cosine similarity on a large array without a worker *will* freeze the user's typing.
*   **Dependency Injection:** Do not simplify the `deps.js` file. It is the only reason your tests pass.
