## Implementation Plan

### Change 1: Enforce Past-Tense Summaries (Prompt Engineering)
**Goal:** Prevent LLM confusion by ensuring extracted memories are explicitly written as past events, not occurring "now."

**Files to Modify:**
1.  `src/prompts.js`

**Action Items:**
1.  **Update `buildExtractionPrompt` function:**
    *   Modify the `<summary_guidelines>` section.
    *   Add a rule explicitly demanding **Past Tense**.
    *   Add a rule asking for "Temporal Context" (e.g., "during the fight," "after the argument") to anchor the memory.
2.  **Update `<example>` sections:**
    *   Rewrite the JSON output examples in `buildExtractionPrompt` to reflect this tense change.
    *   *Current:* "Elena kills her brother..."
    *   *Target:* "Elena **killed** her brother..."

**Specific Instruction for Code:**
```javascript
// In src/prompts.js inside buildExtractionPrompt string:
<summary_guidelines>
...
- Tense: ALWAYS use Past Tense (e.g., "walked", "discovered", "confessed").
  BAD: "Elena confesses to the crime." (Implies it is happening now)
  GOOD: "Elena confessed to the crime during the interrogation."
- Context: Anchor the event if possible (e.g., "during the storm", "at the tavern").
...
</summary_guidelines>
```

---

### Change 2: Relationship State Decay (Drift)
**Goal:** Prevent relationship stats (Trust/Tension) from getting stuck at max/min values by slowly drifting them back toward neutral/baseline over time if no interactions occur.

**Files to Modify:**
1.  `src/constants.js`
2.  `src/utils.js` (or a new `src/mechanics.js` if preferred, but `utils` is fine for helper logic)
3.  `src/extraction/parser.js`

**Action Items:**
1.  **Define Constants (`src/constants.js`):**
    *   `RELATIONSHIP_DECAY_INTERVAL`: How many messages must pass before decay triggers (e.g., 50).
    *   `TENSION_DECAY_RATE`: How much tension drops per interval (e.g., 0.5 - tension dissipates naturally).
    *   `TRUST_DECAY_RATE`: How much high trust drops per interval (e.g., 0.1 - trust is stickier).
2.  **Add Decay Logic (`src/extraction/parser.js`):**
    *   In `updateRelationshipsFromEvents`, or a new function called immediately after it.
    *   Iterate through all relationships in `data[RELATIONSHIPS_KEY]`.
    *   Compare `currentMessageId` (from context) vs the last entry in `relationship.history`.
    *   **Formula:**
        *   If `last_interaction_delta > RELATIONSHIP_DECAY_INTERVAL`:
        *   `Tension` = Move towards 0.
        *   `Trust` = If > 5, move slightly towards 5. (Don't decay *low* trust/hatred automatically, that usually stays).
3.  **Update Data Structure:**
    *   Ensure relationships have a `last_updated_message_id` property to track the delta accurately.

---

### Change 3: Offload Scoring to Web Worker
**Goal:** Prevent UI freezing during the retrieval step when scoring 1000+ memories with vector math.

**Files to Modify:**
1.  `src/retrieval/scoring.js`
2.  `src/retrieval/worker.js` (New File)

**Action Items:**
1.  **Create `src/retrieval/worker.js`:**
    *   This file will contain the heavy math logic currently in `selectRelevantMemoriesSimple`.
    *   It should accept a message `onmessage` containing: `{ memories, contextEmbedding, settings, chatLength }`.
    *   It should include the `cosineSimilarity` function and the `Forgetfulness Curve` logic.
    *   It returns the sorted, sliced array of relevant memories.

2.  **Refactor `src/retrieval/scoring.js`:**
    *   Remove the synchronous `map/sort` logic from `selectRelevantMemoriesSimple`.
    *   Implement a `runWorkerScoring` function that:
        1.  Initializes the worker (using `new Worker(new URL('./worker.js', import.meta.url))`).
        2.  Sends the data.
        3.  Returns a `Promise` that resolves when the worker posts back the results.
    *   Add error handling: If the worker fails or times out (5s limit), fallback to the main thread synchronous calculation.

**Structure for `src/retrieval/worker.js`:**
```javascript
self.onmessage = function(e) {
    const { memories, contextEmbedding, chatLength, constants } = e.data;
    // ... Implement the map() scoring loop here ...
    // ... Implement sort() ...
    self.postMessage(sortedResults);
};
```

**Structure for `src/retrieval/scoring.js` update:**
```javascript
export async function selectRelevantMemoriesSimple(...) {
   // ... setup data ...
   try {
       return await runWorkerScoring(memories, contextEmbedding, ...);
   } catch (err) {
       console.warn("Worker failed, falling back to main thread", err);
       return runSynchronousScoring(...); // The old logic
   }
}
```